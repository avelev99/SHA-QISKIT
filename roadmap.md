# QSHA - Quantum-Salted Hash Tool Roadmap

This document outlines the development roadmap for the QSHA tool, which generates SHA-like hashes incorporating quantum randomness.

## Core Goal

To create a command-line tool that produces a hash digest for an input message, where the hashing process is influenced by random bits generated using a quantum computer (or simulator). The key characteristic is that the same input message will produce different hashes on subsequent runs due to the fresh quantum randomness introduced each time.

## Features

### 1. Quantum Random Bit Generator (QRBG)

*   **Description:** A module responsible for generating a sequence of random bits using quantum circuits based on the `coinflipper.py` logic.
*   **Functionality:**
    *   Accepts the desired number of bits as input.
    *   Connects to IBM Quantum via `QiskitRuntimeService` (requires credentials).
    *   Selects a suitable operational real backend. Fails if connection or backend selection is not possible.
    *   Executes simple 1-qubit Hadamard + Measurement circuits on the selected backend.
    *   Aggregates measurement outcomes (0s and 1s) into a bit sequence.
    *   Handles execution errors gracefully (API issues, backend problems during job run).
    *   Returns the bit sequence.
    *   Indicates the source of randomness (real backend name).
*   **Exclusions:**
    *   Does not use simulators.
    *   Does not perform hashing.
    *   Does not store bits persistently.

### 2. Quantum-Salted Hash Function (QSHA)

*   **Description:** The core hashing logic that combines an input message with a fresh quantum random salt generated by the QRBG.
*   **Functionality:**
    *   Accepts input message (string/bytes) and desired hash length.
    *   Calls QRBG (Feature 1) to get a quantum random salt for each operation.
    *   Implements a deterministic mixing algorithm to combine the message and salt. (Design required - likely involving padding, iterative processing, and XORing/manipulating internal state with salt bits).
    *   Produces a fixed-size hash digest (hexadecimal format).
    *   Ensures non-deterministic output for the same input message across runs.
*   **Exclusions:**
    *   Not a standard SHA implementation.
    *   Not suitable for deterministic hashing needs.
    *   Cryptographic properties (like collision resistance) are distinct from standard SHA and require analysis.
    *   Not an encryption algorithm.

### 3. Command-Line Interface (CLI) Tool

*   **Description:** A user-facing script to interact with the QSHA functionality.
*   **Functionality:**
    *   Executable script (e.g., `qsha_cli.py`).
    *   Parses command-line arguments for input message and hash length.
    *   Imports and utilizes the QSHA function (Feature 2), handling potential initialization errors.
    *   Prints the final hash digest to stdout.
    *   Provides basic execution information (QRBG source - real backend name).
*   **Exclusions:**
    *   Does not implement core logic (delegates to Features 1 & 2).
    *   No GUI.
    *   Does not offer simulator usage.
    *   Simple configuration (API keys handled externally).

## Development Steps

1.  **Refactor `coinflipper.py`:** Create a reusable QRBG module/class based on the existing logic.
2.  **Design QSHA Algorithm:** Define the specific steps for padding, processing blocks, and incorporating the quantum salt into the hash state.
3.  **Implement QSHA Function:** Code the QSHA logic using the QRBG module.
4.  **Develop CLI:** Create the command-line interface script.
5.  **Testing:** Implement unit and integration tests for QRBG and QSHA. Test the CLI manually.
6.  **Documentation:** Add docstrings and potentially a README update.
